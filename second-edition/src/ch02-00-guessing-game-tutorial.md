# Гра "відгадай число"

Розпочнемо вивчення Rust зі спільної розробки проєкта! Цей розділ ознайомить 
вас із кількома поширеними концепціями Rust, показавши вам, як вони 
використовуються у реальній програмі. Ви дізнаєтеся про `let`, `match`, 
методи, асоційовані функції, використання зовнішніх crate-ів, і навіть 
більше! Наступні розділи розкриють більше деталей цих ідей. У цьому розділі, 
ви займатиметеся основами.

Ми розв'язуватимемо класичну задачу для програмістів-початківців: гру "відгадай
число". Умови такі: програма генерує випадкове ціле число між 1 та 100. Потім
пропонує гравцю відгадати. Ввівши спробу, вона скаже, чи число більше або менше
за неї. Якщо відгадано правильно, гра виведе вітання і припинить роботу.

## Початок нового проєкту

Щоб розпочати новий проєкт, перейдіть до папки *projects*, яку ви створили у 
Розділі 1, і створіть новий проєкт за допомогою Cargo, ось так:

```text
$ cargo new guessing_game --bin
$ cd guessing_game
```

Перша команда, `cargo new`, приймає першим параметром ім'я проєкту 
(`guessing_game`). Прапорець `--bin` каже Cargo зробити двійковий проєкт, так
само, як і в Розділі 1. Друга команда переходить до теки нового проєкту.

Переглянемо щойно створений файл *Cargo.toml*:

<span class="filename">Filename: Cargo.toml</span>

```toml
[package]
name = "guessing_game"
version = "0.1.0"
authors = ["Ваше ім'я <адреса@поштовий.сайт>"]

[dependencies]
```

Якщо інформація про автора, отримана Cargo з вашого середовища, неправильна,
виправіть це і знову збережіть файл.

Як ви вже бачили у Розділі 1, `cargo new` створює програму "Hello, world!". 
Подивимося, що міститься у файлі *src/main.rs*:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    println!("Hello, world!");
}
```

Скомпілюймо цю програму “Hello, world!” і запустимо її за один крок за допомогою
команди `cargo run`: 

```text
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Hello, world!
```

Команда `run` стає в нагоді, коли треба швидко розвивати проєкт, і ця гра є
якраз таким проєктом: ви хочемо швидко тестувати кожну ітерацію перед тим, як
переходити до наступної.

Знову відкрийте файл *src/main.rs*. Весь код ви будете писати у ньому.

## Обробляємо здогадку

Перша частина програми буде запитувати у користувача ввести здогадку, обробляти
те, що він увів, і перевіряти, чи ввів він дані у потрібній формі. Для початку,
дозволимо користувачеві ввести здогадку. Введіть код з Роздруку 2-1 до 
*src/main.rs*.

<span class="filename">Filename: src/main.rs</span>

```rust,ignore
use std::io;

fn main() {
    println!("Відгадай число!");

    println!("Введіть здогадку.");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .expect("Не вдалося прочитати рядок");

    println!("Ваша здогадка: {}", guess);
}
```

<span class="caption">Роздрук 2-1: Код, що отримує здогадку у користувача і виводить її</span>

Цей код містить багато інформації, тому розбиратимемо його шматок за шматком. 
Щоб отримати, що ввів користувач, і вивести результат, нам треба ввести 
бібліотеку `io` (ввід/вивід, англ. input/output) у межі дії. Бібліотека
`io` входить до стандартної бібліотеки (яка зветься `std`).

```rust,ignore
use std::io;
```

Усталено Rust вводить в межі дії тільки декілька типів у 
[*прелюдії* (*prelude*)][prelude]<!-- ignore -->. Якщо типу, який ви хочете 
використати, нема у прелюдії, вам доведеться явно вносити цей тип у межі дії 
за допомогою виразу `use`.  Використання бібліотеки `std::io` надає 
вам ряд корисних речей, пов'язаних із введенням-виведенням, включно з 
функціональністю для користувацького вводу.

[prelude]: ../../std/prelude/index.html

Як ви бачили у Розділі 1, функція `main` - це точка входу в програму:

```rust,ignore
fn main() {
```

Синтаксична конструкція `fn` проголошує нову функцію, `()` показує, що вона не 
має параметрів, і `{` починає тіло функції.

Як ви вже знаєте з Розділу 1, `println!` - це макрос, що виводить стрічку на
екран:

```rust,ignore
println!("Відгадай число!");

println!("Введіть здогадку.");
```

Цей код просто виводить повідомлення, що це за гра і запит введення у 
користувача.

### Зберігання значень у змінних

Тепер створімо місце для зберігання вводу користувача, ось так:

```rust,ignore
let mut guess = String::new();
```

Тепер програма стає цікавішою! В цьому коротенькому рядку відбувається багато
всього. Зверніть увагу на інструкцію `let`, що використовується для створення 
*змінних*. Ось інший приклад:

```rust,ignore
let foo = bar;
```

Цей рядок створить нову змінну з назвою `foo` і зв'яже її зі значенням `bar`. 
У Rust, змінні типово є сталими (immutable). Наступний приклад показує, як 
використовується `mut` перед іменем змінної, зробити її несталою (mutable):

```rust,ignore
let foo = 5;     // стала
let mut bar = 5; // нестала
```

> Зверніть увагу: синаксична конструкція `//` починає коментар, що продовжується
> до кінця рядка. Rust ігнорує весь вміст коментаря.

Тепео ви знаєте, що `let mut guess` створить несталу змінну, на ім'я `guess`. З
іншого боку знаку рівності `=` знаходиться значення, з яким зв'язується 
`guess`, а саме - результат виклику `String::new`, функції, що повертає новий екземпляр стрічки String. [`String`][string]<!-- ignore --> - це тип стрічки, 
що надається стандартною бібліотекою; це кодовані в UTF-8 шматки тексту, які 
можна нарощувати.

[string]: ../std/string/struct.String.html

Синаксична конструкція `::` в рядку `::new` позначає, що `new` - це 
*асоційована функція* типу `String`. Асоційована функція є реалізованою для 
типу, в цьому випадку `String`, а не для конкретного екземпляра `String`. В 
деяких мовах це зветься *статичним методом*.

Ця функція `new` створює нову, пусту `String`. Функція `new` зустрінеться вам у
багатьох типах, оскільки це звичайна назва функції, що створює нове значення
певного виду.

Підсумуємо: рядок `let mut guess = String::new();` створив несталу змінну, 
зараз прив'язану до нового, пустого екземпляру `String`. Уф!

Згадаймо, що ми додали функціональність введення/виведення зі стандартної 
бібліотеки за допогою `use std::io;` у першому рядку програми. Тепер ми 
викличемо асоційовану функцію `stdin` з `io`.

```rust,ignore
io::stdin().read_line(&mut guess)
    .expect("Не вдалося прочитати рядок.");
```

Якби на початку програми не було рядка `use std::io`, ми могли б записати цей
виклик функції як `std::io::stdin`. Функциія `stdin` повертає екземпляр
[`std::io::Stdin`][iostdin]<!-- ignore -->; цей тип репрезентує дескриптор
(handle) стандартного потоку введення терміналу.

[iostdin]: ../std/io/struct.Stdin.html

Наступна частина коду, `.read_line(&mut guess)`, викликає метод
[`read_line`][read_line]<!-- ignore --> на дескрипторі стандартного потоку 
введення, щоб отримати, що ввів користувач. Також ми передаємо `read_line`
один параметр: `&mut guess`.

[read_line]: ../std/io/struct.Stdin.html#method.read_line

`read_line` бере все, що користувач вводить у стандартний потік введення, і 
розміщує це в стрічці, тому приймає цю стрічку аргументом. Цей аргумент мусить
бути несталим, щоб метод змінив вміст стрічки, додавши те, що ввів користувач.

`&` позначає, що цей аргумент - *посилання*, що дає вам можливість надати 
кільком частинам вашого коду доступ до одного фрагменту даних без
кількаразового копіювання цих даних. Посилання - складна тема, але одна з 
основних переваг Rust полягає в безпеці і легкості використання посилань. Для
завершення цієї програми вам не знадобляться особливо детальні знання про 
посилання; в Розділі 4 будуть надані докладніші пояснення. Поки що все, що вам
треба знати - що посилання, як і зміні, типово є сталими. Тому необхідно 
писати `&mut guess`, а не просто `&guess`, щоб зробити її несталою.

Ми ще не закінчили розбиратися із цим рядком коду. Хоча це один рядок тексту,
це лише перша частина єдиного логічного рядка коду. Друга частина - це ось цей 
метод:

```rust,ignore
.expect("Не вдалося прочитати рядок");
```

Коли ви викликаєте метод за допомогою синтаксичної конструкції `.foo()` часто 
має сенс розпочати новий рядок і додати відступи, щоб розділити довгі рядки. Ми
могли б написати цей код так:

```rust,ignore
io::stdin().read_line(&mut guess).expect("Не вдалося прочитати рядок");
```

Але довгий рядок важко читати, тому краще поділити його на два рядки для 
виклику двох методів. Тепер розглянемо, що цей рядок робить.

### Керування потенційною невдачею за допомогою типу `Result`

Як вже було сказано, `read_line` виводить те, що ввів користувач, у стрічку, 
яку ми їй передали, але також повертає значення - в цьому випадку, 
[`io::Result`][ioresult]<!-- ignore -->. В стандартній бібліотеці Rust є 
кілька типів, що звуться Result: як звичайний [`Result`][result]<!-- ignore -->,
 так і спеціалізовані версії в підмодулях, як-от `io::Result`.

[ioresult]: ../std/io/type.Result.html
[result]: ../std/result/enum.Result.html

Типи `Result` - це [*переліки* (*enumeration*)][enums]<!-- ignore -->, які 
часто звуть просто *enum* (вимовляється "енам"). Перелік - це тип, який може 
набувати значення з визначеного набору, і ці значення звуться *варіантами* enum-а. Розділ 6 детальніше розкриє роботу enum-ів.

[enums]: ch06-00-enums.html

`Result` має варіанти `Ok` та `Err`. `Ok` показує, що операція була вдалою, і
всередині варіанту `Ok` знаходиться успішно згенероване значення. `Err` 
позначає відмову, і містить інформацію, як і чому операція була невдалою.

Призначення типів `Result` - кодувати інформацію про обробку помилок. Значення 
типу `Result`, які інших типів, мають методи, визначені для них. Екземпляр 
`io::Result` має [метод `expect`][expect]<!-- ignore -->, який можна викликати.
Якщо цей екземпляр `io::Result` має значення `Err`, то `expect` викличе 
аварійне завершення програми і виведе повідомлення, яке ви передали параметром 
`expect`. Якщо метод `read_line` поверне `Err`, це, швидше за все, буде 
результатом помилки в операційній системі. Якщо цей екземлпяр `io::Result` має 
значення `Ok`, `expect` візьме значення, яке знаходиться в `Ok`, і поверне 
тільки це значення, щоб їм можна було скористатися. В цьому випадку це 
значення - кількість байтів, введених користувачем до стандартного потоку.

[expect]: ../std/result/enum.Result.html#method.expect

Якщо ми не викличемо `expect`, програма скомпілюється, проте ми отримаємо
попередження:

```text
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `std::result::Result` which must be used
  --> src/main.rs:10:5
   |
10 |     io::stdin().read_line(&mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(unused_must_use)] on by default
```

Rust попереджає, що ми не використали значення `Result`, повернуте з 
`read_line`, що означає, що програма не обробила можливу помилку. Правильний 
спосіб пригнітити попередження - власне, обробити помилку, але оскільки ми 
просто хочемо, щоб програма аварійно завершилася, якщо виникне проблема, можна
скористатися `expect`. Ви дізнаєтеся про те, як відновити роботу програми при
помилці, у Розділі 9.

### Вивід значень за допомогою заповнювачів `println!`

Якщо не враховувати закриваючої фігурної дужки, поки щол ишився лише один 
рядок, який ми ще не обговорили, а саме:

```rust,ignore
println!("Ваша здогадка: {}", guess);
```

Цей рядок виводить стрічку, в якій ми зберегли те, що ввів користувач. Символи
`{}` - це заповнювач, який замінюється значенням. Ви можете вивести більше 
одного значення за допомогою `{}`: перший набір `{}` замінюється першим 
значенням після форматної стрічки, другий набір - другим значенням і так далі.
Вивід багатьох значень за один виклик `println!` виглядатиме так:

```rust
let x = 5;
let y = 10;

println!("x = {} і y = {}", x, y);
```

Цей код виведе `x = 5 і y = 10`.

### Тестування першої частини

Протестуймо першу частину гри "відгадай число". Запустіть її за допомогою
`cargo run`:

```text
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Відгадай число!
Введіть здогадку.     
6
Ваша здогадка: 6
```

На цей момент перша частина гри завершена: ви отримуємо дані з клавіатури і
виводимо їх.

## Генерація таємного числа

Тепер нам треба згенерувати таємне число, яке користувач пробуватиме відгадати.
Таємне число має бути різним кожного разу, щоб у гру було цікаво грати більше
одного разу. Використаймо випадкове число від 1 до 100, щоб гра була не надто
складною. Rust поки що не має функціональності для генерації випадкових чисел у
стандартній бібліотеці; натомість команда Rust надає [crate `rand`][randcrate].

[randcrate]: https://crates.io/crates/rand

### Використання crate для отримання додаткової функціональності

Згадаймо, що *crate* - це пакет коду Rust. Проєкт, який ми робимо - *двійковий 
crate* і є виконанним. Crate `rand` - *бібліотечний crate*, і містить код, 
призначений для використання в інших програмах.

Використання зовнішніх crate-ів - найсильніший бік Cargo. Перед тим, як писати 
код, що використовує `rand`, ми маємо модифікувати файл *Cargo.toml*, додавши 
туди crate `rand` як залежність. Відкрийте цей файл і додайте такий рядок 
унизу, під заголовком секції `[dependencies]`, яку для вас створив Cargo:

<span class="filename">Файл: Cargo.toml</span>

```toml
[dependencies]

rand = "0.3.14"
```

У файлі *Cargo.toml* все, що йде після заголовку - частина секції, що 
продовжується до початку нової секції. У секції `[dependencies]` ви 
повідомляєте Cargo, від яких зовнішніх crate-ів залежить і які версії цих 
crate-ів вам потрібні. У цьому випадку, ми зазначаємо crate `rand` зі 
семантичним версіонуванням `0.3.14`. Cargo розуміє [семантичне версіонування][
semver]<!-- ignore -->  (також зване *SemVer*), що є стандартом для запису 
номеру версії. Запис `0.3.14` насправді є скороченням для `^0.3.14`, що 
означає "будь-яка версія, що має публічний API, сумісний із версією 0.3.14".

[semver]: http://semver.org

Тепер, не змінюючи коду, побудуємо проєкт, як показано в Роздруку 2-2:

```text
$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.14
 Downloading libc v0.2.14
   Compiling libc v0.2.14
   Compiling rand v0.3.14
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
```

<span class="caption">Роздрук 2-2: Вивід команди `cargo build` після додавання
 crate-у rand як залежності.</span>

Ви можете побачити інші номери версій (але вони будуть сумісні з кодом завдяки
SemVer!), і рядки можуть бути в іншому порядку.

Тепер, коли ми маємо зовнішню залежність, Cargo витягає останні версії всього,
що нам треба, з *реєстру*, тобто копії даних з [Crates.io][cratesio]. На 
crates.io в екосистемі Rust люди викладають свої проєкти з відкритим кодом, щоб
ними могли скористатися інші.

[cratesio]: https://crates.io

Після оновлення реєстру, Cargo перевіряє розділ `[dependencies]` і завантажує 
ті, яких у вас бракує. В цьому випадку, хоча ми вказали тільки залежність від
`rand`, Cargo також завантажив копію `libc`, тому що `rand` залежить від 
`libc`. Після завантаження, Rust компілює їх і потім компілює проєкт із 
доступними залежностями.

Якщо ви знову запустите `cargo build`, не зрозбивши жодних змін, ви не 
отримаєте жодної відповіді. Cargo знає, що він вже завантажив і скомпілював 
залежності, а ви не змінили нічого у своєму коді, тому він теж не буде 
перекомпільовуватися. Оскільки роботи у Cargo немає, він просто завершується. 
Якщо ви відкриєте файл *src/main.rs*, зробите тривіальну зміну, збережете і 
знову побудуєте, то побачите тільки два рядки виводу:

```text
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
```

Ці рядки показують, що Cargo обробив тільки вашу дрібну зміну до файлу 
*src/main.rs*. Залежності не змінилися, і Cargo знає, що може заново 
використати те, що він вже завантажив і скомпілював. Він перебудовує тільки 
вашу частину коду.

#### Файл *Cargo.lock* гарантує відтворюваність побудови

Cargo має механізм, що гарантує однаковість побудови проєкту кожного разу, 
коли ви чи хтось інший будує ваш код: Cargo використає тільки ті версії 
залежностей, які ви зазначили, доки ви не вкажете інші. Наприклад, якщо
наступного тижня вийде `rand` версії `0.3.15`, що міститиме важливе виправлення
вади, але також регресію, що зіпсує ваш код?

Відповідь на цю задачу - файл *Cargo.lock*, що створюється при першому запуску
`cargo build` і розміщується у теці *guessing_game*. Коли ви збираєте проєкт
вперше, Cargo визначає всі версії залежностей, що відповідають критерію, і 
записує їх у файл *Cargo.lock*. Коли ви пізніше збиратимете проєкт, Cargo 
побачить, що файл *Cargo.lock* існує, і використає версії, зазначені там, а не
буде наново визначати версії. Це дозволяє вам автоматично мати відтворювану 
збірку. Іншими словами, ваш проєкт залишиться на версії `0.3.14`, доки ви самі
не захочете оновити її, завдяки файлу *Cargo.lock*.

#### Оновлення crate-а для отримання нової версії

Коли ви *хочете* оновити crate, Cargo надає іншу команду, `update`, яка:
1. Ігнорує файл *Cargo.lock* і визначає всі останні версії, що відповідають
специфікаціям в *Cargo.toml*.
1. Якщо це вдалося, Cargo напише ці версії до файлу *Cargo.lock*.

Але типово Cargo шукатиме тільки  версії, більші за `0.3.0` і менші `0.4.0`. 
Якщо crate `rand` вийшов у двох нових версіях, `0.3.15` та `0.4.0`, ви побачите
таке, запустивши `cargo update`:

```text
$ cargo update
    Updating registry `https://github.com/rust-lang/crates.io-index`
    Updating rand v0.3.14 -> v0.3.15
```

Також можна звернути увагу на зміну у файлі *Cargo.lock* - версія crate-а 
`rand`, яку ви використовуєте, тепер `0.3.15`.

Якщо вам потрібен `rand` версії `0.4.0` чи будь-якої версії у гілці `0.4.x`, 
вам доведеться оновити файл *Cargo.toml*, щоб він мав такий рядок:

```toml
[dependencies]

rand = "0.4.0"
```

Наступного разу, коли ви запустите `cargo build`, Cargo оновить реєстр 
доступних crate-ів і переоцінить вимоги до `rand` відповідно до вказаної вами 
нової версії.

Можна багато сказати про [Cargo][doccargo]<!-- ignore --> і 
[його екосистему][doccratesio]<!-- ignore -->, яка обговорюється у Розділі 14,
але поки що цього знати достатньо. Cargo робить використання бібліотек дуже 
простим, що дозволяє растацеанцям писати менші проєкти, зібрані з кількох 
пакетів.

[doccargo]: http://doc.crates.io
[doccratesio]: http://doc.crates.io/crates-io.html

### Генерація випадкового числа

Почнемо *використовувати* `rand`. Наступний крок - оновити *src/main.rs*, як
показано в Роздруку 2-3:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!("Відгадай число!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("Таємне число: {}", secret_number);

    println!("Будь ласка, введіть здогадку:");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .expect("Не вдалося прочитати рядок");

    println!("Ваша здогадка: {}", guess);
}
```

<span class="caption">Роздрук 2-3: Зміни в коді, необхідні для генерації 
випадкового числа </span>

Ми додаємо рядок `extern crate rand;` на початок, що дає Rust знати, що ми 
будемо використовувати зовнішню залежність. Це, на додачу, є еквівалентним 
`use rand`, так що тепер ми можемо викликати будь-що з crate-а `rand`, додавши 
префікс `rand::`.

Далі ми додаємо ще один рядок із `use` - `use rand::Rng`. `Rng` - це trait, що 
визначає методи, втілені генераторами випадкових чисел, і цей trait має бути в 
області видимості, щоб можна було використовувати ці методи. Trait-и детальніше
розкриваються у Розділі 10.

Також, ми додали ще два рядки всередині. Функція `rand::thread_rng` дає нам
конкретний генератор випадкових чисел, який ми будемо використовувати: 
локальний для чинного потоку виконання та ініціалізований операційною 
системою. Далі, ви викликаємо метод `gen_range` цього генератора. Цей метод 
визначений trait-ом `Rng`, який ми внесли до області видимості за допомогою 
інструкції `use rand::Rng`. Метод `gen_range` приймає два числа параметрами і 
генерує випадкове число між ними, включно з нижньою межею, але виключаючи 
верхню, тому треба вказувати `1` та `101`, щоб отримати число між 1 та 100 
включно.

Знання, які риси використати і які функції та методи викликати з crate-у не є 
чимось таким, що треба знати напам'ять. Інструкції з використання crate-у є в 
документації цього crate-у. Ще одна корисна особливість Cargo полягає в тому, 
що запуск команди `cargo doc --open` побудує на вашому комп'ютері 
документацію, надану всіма залежностями, і відкриє її у вашому переглядачі. 
Якщо вам цікава інша функціональність crate-а `rand`, запустіть `cargo doc 
--open` і клацніть `rand` на боковій панелі ліворуч.

Другий рядок, який ми додали до коду, виводить таємне число. Це корисно, коли
ми розробляємо програму, щоб можна було перевірити її роботу, але ми видалимо 
її у фінальній версії. Буде не дуже цікаво, якщо програма виводитиме відповідь
одразу по запуску!

Спробуємо запустити програму кілька разів:

```text
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Відгадай число!
Таємне число: 7
Будь ласка, введіть здогадку:
4
Ваша здогадка: 4
$ cargo run
     Running `target/debug/guessing_game`
Відгадай число!
Таємне число: 83
Будь ласка, введіть здогадку:
5
Ваша здогадка: 5
```

Ви маєте побачити різні випадкові числа, і вони мають бути між 1 та 100. Чудово!

## Порівняння здогадки з таємним числом

Тепер, коли ми маємо введене користувачем і випадкове числа, ми можемо їх 
порівняти. Цей крок показано в Роздруку 2-4:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Відгадай число!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("Таємне число: {}", secret_number);

    println!("Будь ласка, введіть здогадку:");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .expect("Не вдалося прочитати рядок");

    println!("Ваша здогадка: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less    => println!("Замало!"),
        Ordering::Greater => println!("Забагато!"),
        Ordering::Equal   => println!("Ви перемогли!"),
    }
}
```

<span class="caption">Роздрук 2-4: Різні дії в залежності від порівняння двох 
чисел</span>

Перше нововведення - ще один `use`, який вводить тип `std::cmp::Ordering` зі
стандартної бібліотеки у межі дії. `Ordering` ("впорядкування") - це 
ще один enum, як і `Result`, але варіанти `Ordering` такі: `Less` ("менше"),
`Greater` ("більше"), and `Equal` ("рівно"). Це три можливі результати при
порівнянні двох чисел.

Потім ми додали в кінець коду п'ять нових рядків, в яких використали тип 
`Ordering`:

```rust,ignore
match guess.cmp(&secret_number) {
    Ordering::Less => println!("Замало!"),
    Ordering::Greater => println!("Забагато!"),
    Ordering::Equal => println!("Ви перемогли!"),
}
```

Метод `cmp` порівнює два значення і може бути викликаний для всього, що можна
порівнювати. Він приймає параметром посилання на те, що ви хочете порівнювати 
із ним: тут він порівнює `guess` із `secret_number`. `cmp` повертає варіант з 
enum-у `Ordering`, який ми внесли у межі дії за допомогою інструкції `use`. Ми
скористалися виразом [`match`][match]<!-- ignore -->, щоб визначити, що робити
далі залежно від варіанту `Ordering`, що його повернув виклик `cmp` зі 
значеннями `guess` та `secret_number`.

[match]: ch06-02-match.html

Вираз `match` збирається з *рукавів* (у інших мовах такі конструкції зазвичай 
звуться гілками). Рукав складається зі *зразка* (*pattern*) та коду, який буде 
виконано, якщо значення, передане виразу `match`, відповідає зразку цього 
рукава. Rust бере значення, передане `match`, і по черзі переверяє зразки 
рукавів. Конструкція `match` і зразки - потужні засоби мови Rust, які 
дозволяють вам виражати різноманітні ситуації, які можуть трапитися вам при 
програмуванні, і допомагають переконатися, що ви обробили їх усіх. Детально ці 
можливості будуть розглянуті в Розділах 5 і 18, відповідно.

Давайте розберемо, як спрацює в цьому коді вираз `match`. Нехай користувач увів
50, а випадково згенероване цього разу таємне число - 38. Коли код порівнює 50
і 38, метод `cmp` поверне `Ordering::Greater`, бо 50 більше за 38. Це значення
отримує вираз `match`. Він перевіряє зразок першого рукава, `Ordering::Less`,
але значення `Ordering::Greater` не відповідає `Ordering::Less`. Тому код цього
рукава ігнорується і ми переходимо до наступного рукава. Зразок другого рукава,
`Ordering::Greater`, *відповідає* `Ordering::Greater`! Код цього рукава буде 
виконано і виведе на екран `Забагато!`. Вираз `match` завершується, бо в цьому
конкретному випадку більше нема сенсу перевіряти останній рукав.

Але код у Роздруку 2-4 все ще не компілюється. Спробуємо його скопмілювати:

```text
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --> src/main.rs:23:21
   |
23 |     match guess.cmp(&secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `std::string::String`, found integral variable
   |
   = note: expected type `&std::string::String`
   = note:    found type `&{integer}`

error: aborting due to previous error
Could not compile `guessing_game`.
```

Суть цієї помилки в тому, що тут є *невідопвідні типи*. Rust має сильну, 
статичну систему типів. Разом із тим, він має систему виведення типів. Коли ви
писали `let guess = String::new()`, Rust зміг вивести, що `guess` має бути типу
`String` і не просив нас написати тип. `secret_number`, з іншого боку, 
числового типу. Кілька числових типів можуть мати значення між 1 та 100: 
`i32`, знакове 32-бітне число; `u32`, беззнакове 32-бітне число; `i64`, 
знакове 64-бітне число і кілька інших. Типовий вибір Rust `i32`, і це й буде 
типом `secret_number`, якщо ми не додамо інформацію про тип деінде, щоб 
змусити Rust вивести інший числовий тип. Причина ж цієї помилки полягає в 
тому, що Rust не може порівнювати стрічку і числовий тип.

Зрештою, ми хочемо перетворити стрічку `String`, яку програма прочитала з 
клавіатури, в числовий тип, щоб можна було порівняти його зі таємним числом. Це
можна зробити, додавши такі рядки до функції `main`:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Відгадай число!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("Таємне число: {}", secret_number);

    println!("Будь ласка, введіть здогадку:");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .expect("Не вдалося прочитати рядок");

    let guess: u32 = guess.trim().parse()
        .expect("Будь ласка, введіть число!");

    println!("Ваша здогадка: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less    => println!("Замало!"),
        Ordering::Greater => println!("Забагато!"),
        Ordering::Equal   => println!("Ви перемогли!"),
    }
}
```

Ось два нові рядки:

```rust,ignore
let guess: u32 = guess.trim().parse()
    .expect("Будь ласка, введіть число!");
```

Ми створили змінну з назвою `guess`. Але чекайте, в програмі вже ніби існує 
змінна з назвою `guess`? Так, але Rust дозволяє *затінювати* попереднє значення
`guess` новим. Ця особливість часто використовується у схожих ситуаціях, коли
нам треба перевторити значення з одного типу в інший. Затінення дозволяє нам
наново використати ім'я змінної `guess`, щоб не довелося створювати дві окремі 
змінні на кшталт `guess_str` і `guess`. Розділ 3 детальніше розповідає про 
затінення.

Ми зв'язали `guess` з виразом `guess.trim().parse()`. `guess` в цьому виразі - 
це перша змінна `guess`, яка має тип `String`, в якій міститься те, що ввів
користувач. Метод `trim`, застосований до екземпляру `String`, видалить всі 
пробільні символи на початки і в кінці. `u32` може бути створений лише зі 
стрічки, яка містить тільки цифри, але користувач має натиснути на <span class=
"keystroke">enter</span>, щоб спрацював метод `read_line`. При цьому в кінець 
стрічки додається символ нового рядка. Наприклад, якщо користувач набере <span
class="keystroke">5</span> і натисне <span class="keystroke">enter</span>, 
`guess` буде виглядати як `5\n`, де `\n` представляє символ нового рядка. 
Метод `trim` видалить `\n`, і залишиться просто `5`.

[Метод `parse` для стрічок][parse]<!-- ignore --> розбирає стрічку, виділяючи 
число певного виду. Оскільки цей метод може виділяти різні числові типи, там 
необхідно вказати Rust, який саме числовий тип ми хочемо отримати - за 
допомогою`let guess: u32`. Двокрапка `:` після `guess` каже Rust, що ми 
позначаємо тип змінної. В Rust є кільки вбудованих числових типів; ми вибрали 
`u32` - беззнакове 32-бітне ціле. Це непоганий вибір для невеликих додатних 
чисел. Про інші типи ви дізнаєтеся у Розділі 3. На додачу, саме позначка `u32` 
у цьому прикладі і порівняння із `secret_number` дає Rust можливість вивести, 
що `secret_number` теж має бути `u32`. І тепер порівнюватимуться два значення 
одного типу!

[parse]: ../std/primitive.str.html#method.parse

Виклик `parse` може легко призвести до помилки. Якщо, наприклад, стрічка 
містить`A👍%`, її неможливо перетворити на число. Оскільки метод може 
завержитися невдачею, він повертає `Result`, майже так само, які  метод `
read_line`, про який ми вже говорили раніше в підрозділі "Керування 
потенційною невдачую за допомогою типу `Result`". Ви обробимо цей `Result` так
само - за допомогою методу `expect`. Якщо `parse` поверне варіант `Err`,
значить, він не зміг створити число зі стрічки, `expect` припинить гру і 
виведе повідомлення, яке ми йому надали. Якщо `parse` вдало створив число зі 
стрічки, він поверне варіант `Ok`, а `expect` поверне потрібне нам число зі 
значення `Ok`.

А тепер запустімо програму!

```text
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running `target/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
```

Чудово! Хоча ми й додали пробіли перед здогадкою, програма все одно зрозуміла,
що користувач увів 76. Запустіть програму кілька разів, щоб перевірити різну
поведінку на різних введених даних: введіть таємне число, більше за нього і 
менше.

Гра тепер майже працює, але користувачеві надається тільки одна можливість 
вгадати. Змінимо це, додавши цикл!

## Введення кількох здогадок за допомогою циклів

Ключове слово `loop` створює нескінчений цикл. Додамо його, щоб дати 
користувачам більше можливостей відгадати число:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Відгадай число!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("Таємне число: {}", secret_number);

    loop {
        println!("Будь ласка, введіть здогадку:");

        let mut guess = String::new();

        io::stdin().read_line(&mut guess)
            .expect("Не вдалося прочитати рядок");

        let guess: u32 = guess.trim().parse()
            .expect("Будь ласка, введіть число!");

        println!("Ваша здогадка: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less    => println!("Замало!"),
            Ordering::Greater => println!("Забагато!"),
            Ordering::Equal   => println!("Ви перемогли!"),
        }
    }
}
```

Як ви можете бачити, ми перенесли в цикл все від запрошення ввести здогадку і 
до кінця. Зсуньте ці рядки ще чотирма пробіли кожен і знову запустіть програму.
Зверніть увагу, що виникла нова проблема, бо програма робить саме те, що ми їй
сказали: запрошує ввести нову здогадку до нескінченості! Схоже, користувач не
може вийти!

Користувач завжди може перервати програму, натиснувши клавіатурне скорочення
<span class="keystroke">ctrl-c</span>. Але є інший спосіб втекти від цього 
ненажерного чудовиська - згаданий при обговоренні `parse` в підрозділі 
“Порівняння здогадки з таємним числом”: якщо користувач введе щось, крім 
числа, програма аварійно завершиться. Користувач може цим скористатися, щоб 
вийти з програми:

```text
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/guessing_game`
Відгадай число!
Таємне число: 59
Будь ласка, введіть здогадку:
45
Ваша здогадка: 45
Замало!
Будь ласка, введіть здогадку:
60
Ваша здогадка: 60
Забагато!
Будь ласка, введіть здогадку:
59
Ваша здогадка: 59
Ви перемогли!
Будь ласка, введіть здогадку:
вийти
thread 'main' panicked at 'Будь ласка, введіть число!: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:785
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/guess` (exit code: 101)
```

Введення `вийти` дійсно призводить до виходу з гри, але так само спрацює 
будь-що, що не є числом. Тим не менше, це щонайменше не найкращий спосіб. Ми 
хочемо, щоб гра сама зупинялася, коли ми відгадали число.

### Вихід після вдалої здогадки

Запрограмуймо гру виходити, якщо користувач виграв, додавши `break`:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Відгадай число!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("Таємне число: {}", secret_number);

    loop {
        println!("Будь ласка, введіть здогадку:");

        let mut guess = String::new();

        io::stdin().read_line(&mut guess)
            .expect("Не вдалося прочитати рядок");

        let guess: u32 = guess.trim().parse()
            .expect("Будь ласка, введіть число!");

        println!("Ваша здогадка: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less    => println!("Замало!"),
            Ordering::Greater => println!("Забагато!"),
            Ordering::Equal   => {
                println!("Ви перемогли!");
                break;
            }
        }
    }
}
```

Додавання `break;` після `println!("Ви перемогли!");` примусить програму вийти з
циклу, якщо користувач відгадав таємне число. Вихід із циклу призведе до виходу
з програми, бо цикл - це остання частина функції `main`.

### Обробка неправильного введення

Для покращення роботи гри замінимо аварійний вихід при введені не-числа на
ігнорування, щоб користувач міг продовжувати відгадувати. Ми можемо зробити це,
попрацювавши з рядком, де `guess` перетворюється з `String` на `u32`:

```rust,ignore
let guess: u32 = match guess.trim().parse() {
    Ok(num) => num,
    Err(_) => continue,
};
```

Заміна виклику `expect` на вираз `match` - загальний спосіб переходу від 
аварійного завершення програми до реальної обробки помилки. Згадаємо, що метод
`parse` повертає тип `Result`, а `Result` - це enum, що має варіанти `Ok` та 
`Err`. Ми використовуємо тут вираз `match`, так само, як робили з `Ordering`,
що його повертає метод `cmp`.

Якщо `parse` зможе вдало перетворити стрічку на число, він поверне значення 
`Ok`, що міститиме число - результат. Це значення `Ok` буде відповідати зразку 
першого рукава, і весь вираз `match` поверне значення `num`, яке `parse` 
обчислив і поклав всередину значення `Ok`. Це число потрапить саме туди, куди 
нам треба - в нову змінну `guess`, яку ми створюємо.

Якщо `parse` не зможе перетворити стрічку на число, він поверне значення `Err`,
що міститиме більше інформації про помилку. Значення `Err` не відпвідає зразку
`Ok(num)` у першому рукаві `match`, але відповідає зразку `Err(_)` у другому. 
`_` - це узагальнене значення; в цьому випадку, ви кажемо, що хочемо 
відповідати будь-якому `Err`, незалежно від інформації, що міститься у ньому. 
Програма виконає код другого рукава, `continue`, що означає - перейти на 
наступну ітерацію циклу `loop` і, відтак, попросити про наступну спробу. Таким 
чином, програма ігнорує всі помилки, які можуть зустрітися `parse`!

Нарешті все у нашій програмі має працювати як треба. Спробуємо запустити
`cargo run`:

```text
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/guessing_game`
Відгадай число!
Таємне число: 61
Будь ласка, введіть здогадку:
10
Ваша здогадка: 10
Замало!
Будь ласка, введіть здогадку:
99
Ваша здогадка: 99
Забагато!
Будь ласка, введіть здогадку:
foo
Будь ласка, введіть здогадку:
61
Ваша здогадка: 61
Ви перемогли!
```

Відмінно! Лишилася тільки одна дрібна правка, і робота буде завершена: програма
все ще виводить таємне число. Це було необхідно для тестування, але псує гру.
Видаляємо `println!`, який виводить таємне число, і маємо на Роздруку 2-5 
остаточний код:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Відгадай число!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!("Будь ласка, введіть здогадку:");

        let mut guess = String::new();

        io::stdin().read_line(&mut guess)
            .expect("Не вдалося прочитати рядок");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("Ваша здогадка: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less    => println!("Замало!"),
            Ordering::Greater => println!("Забагато!"),
            Ordering::Equal   => {
                println!("Ви перемогли!");
                break;
            }
        }
    }
}
```

<span class="caption">Роздрук 2-5: Повний код гри "відгадай число!"</span>

## Підсумок

Отже, ви зуміли вдало побудувати гри "відгадай число"! Вітаємо!

Цей проєкт був вступом до багатьох концепцій мови Rust через практику: `let`,
`match`, методи, асоційонвані функції, використання зовнішніх crate-ів і т.ін. 
У кількох наступних розділах ми детальніше розберемо ці концепції. Розділ 3 
розповідає про концепції, які є у більшості мов програмування, такі як змінні,
типи даних, функції і показує, як ними користуватися в Rust. Розділ 4 
розповідає про власність, концепцію мови Rust, що є найбільш відмінною від 
інших мов. Розділ 5 обговорює struct-и і методи, а Розділ 6 детально 
розкриває enum-и.
