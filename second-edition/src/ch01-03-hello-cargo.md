## Привіт, Cargo!

Cargo - це система побудови та пакетний менеджер. Більшість Растацеанців 
використовуватимуть цей інструмент для керування проєктами Rust, бо Cargo 
виконує багато задач, таких, як побудова коду, завантаження бібліотек, від яких залежить ваш код, та побудова цих бібліотек (бібліотеки, потрібні коду,
звуться *залежностями* (*dependencies*).

Найпростіші програми Rust, як та, яку ми щойно написали, не мають жодних 
залежностей, тому, якби ми побудували проєкт Hello world за допомогою Cargo,
то скористалися б тільки тією частиною Cargo, що відповідає з побудову коду. 
Якщо ж писати складніші програми Rust, виникне потреба в залежностях, і якщо 
почати проєкт за допомогою Cargo, задовольнити її буде значно легше.

Оскільки переважна більшість проєктів Rust використовують Cargo, надалі в книзі
вважатиметься, що ви теж використовуєте Cargo. Cargo встановлюється з Rust, 
якщо ви скористалися офіційним встановлювачем, як сказано в підрозділі 
“Встановлення”. Якщо ви встановили Rust у інший спосіб, можете перевірити, чи 
встановлений Cargo, ввівши це у свій термінал:

```text
$ cargo --version
```

Якщо ви побачите номер версії, то чудово! Але якщо ви бачите помилку на кшталт
`не знайдено команду`, вам слід звернутися до документації по вашому методу
встановлення, щоб визначити, як окремо встановити Cargo.

### Створення проєкту за допомогою Cargo

Створімо новий проєкт за допомогою Cargo і подивимося, як він відрізняється від
нашого початкового проєкту Hello World. Поверніться до вашої теки *projects* (чи іншої, де знаходиться ваш код) і введіть команди (незалежно від системи):

```text
$ cargo new hello_cargo --bin
$ cd hello_cargo
```

<!-- Below -- so we always have to start a cargo project with the --bin option
if we want it to be something we can execute and not just a library, is that
right? It might be worth laying that out -->
<!-- As of Rust 1.21.0 (the version we're using for the book), yes, you must
always specify `--bin`. In a version of Rust in the near future (1.25 or 1.26),
binary crates will become the default kind of crate that `cargo new` makes, so
you won't have to specify `--bin` (but you can if you want and the behavior
will be the same). We'd rather not go into any more detail than we have here
because of this change; I think "The `--bin` argument to passed to `cargo new`
makes an executable application (often just called a *binary*), as opposed to a
library." lays this out enough. /Carol -->

Це створює новий двійковий виконанний проєкт, що зветься hello_cargo. Аргумент
`--bin`, переданий до `cargo new`, створює виконанний застосунок (який часто 
просто називають *двійковим файлом*); натомість, він міг створити бібліотеку.
Ми ввели `hello_cargo` як назву нашого проєкту, і Cargo створює його файли у 
теці, що зветься так само.

Перейдіть до теки *hello_cargo* і перегляньте файли, і ви побачите, що Cargo 
створив два файли і одну теку: *Cargo.toml* і теку *src* із файлом *main.rs* 
Також він розпочав новий репозиторій git, додавши файл *.gitignore*.

> Примітка: Git - це поширена система контролю версій (version control system, 
> VCS). Ви можете сказати `cargo new` використовувати іншу систему контрою 
> версій чи не використовувати жодної за допомогою прапорця `--vcs`. Запустіть
> `cargo new --help`, щоб побачити можливі варіанти.

Відкрийте файл *Cargo.toml* у будь-якому текстовому редакторі. Він має 
виглядати десь так, як показано у Роздруку 1-2:

<span class="filename">Файл: Cargo.toml</span>

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
authors = ["Ваше Ім'я <email@example.com>"]

[dependencies]
```

<span class="caption">Роздрук 1-2: Вміст файлу *Cargo.toml*, створеного 
командою `cargo new`</span>

Це файл у форматі [*TOML*][toml]<!-- ignore --> (Tom’s Obvious, Minimal
Language - "томова очевидна мінімальна мова"), який Cargo використовує як 
формат для конфігурації.

[toml]: https://github.com/toml-lang/toml

Перший рядок, `[package]` (пакет), це заголовок розділу, що показує, що 
наступні інструкції стосуються конфігурації пакету. Коли ми додамо більше 
інформації до цього файлу, ми додамо й інші розділи.

Наступні три рядки встановлюють конфігураційну інформацію, потрібну Cargo для
компілювання вашої програми: ім'я, версію, і хто її написав. Cargo бере ваше 
ім'я та адресу електронної пошти з налаштувань середовища, і якщо вони 
неправильні, можете їх виправити та зберегти файл.

Останній рядок, `[dependencies]`, розпочинає розділ, де можна вказувати 
залежності вашого проєкту. Пакети з кодом в Rust звуться *Crate*-ами.
Нам не потрібні інші crate-и для цього проєкту, але вони знадобляться для 
першого проєкту у розділі 2, і тоді ж ми скористаємося цим розділом.

Тепер відкрийте файл *src/main.rs* і подивіться на його вміст:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    println!("Hello, world!");
}
```

Cargo створила для вас “Hello World!”, точно такий, який ми написали в 
Роздруку 1-1! Поки що єдина відмінність між нашим попереднім проєктом та 
згенерованим Cargo полягає в тому, що Cargo розмістив код у теці *src*, і додав конфігураційний файл *Cargo.toml* в основній теці.

Cargo очікує, що сирцеві файли будуть розташовані в теці *src*, а основна тека
міститиме лише README (ПРОЧИТАЙМЕНЕ), ліцензійну інформацію, конфігураційні 
файли і все таке, що не стосується вашого коду. Таким чином, використання 
Cargo допоможе вам зберегти свої проекти красивими та охайними. Все має своє 
місце, і все лежить на своїх місцях.

Якщо ви почали проєкт, що не використовує Cargo, як було із нашим проєктом у 
теці *hello_world*, його можна перетворити на проєкт із підтримкою Cargo, перемістивши код до теки *src* і створивши відповідний *Cargo.toml*.

### Побудова і запуск проєкту Cargo

Поглянемо на особливості побудови і запуску програми Hello World із Cargo. З 
теки проєкту, побудуйте проєкт такими командами:

```text
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```

Це створить виконанний файл *target/debug/hello_cargo* (чи
*target\\debug\\hello_cargo.exe* на Windows), який можна запустити такою 
командою:

```text
$ ./target/debug/hello_cargo # чи .\target\debug\hello_cargo.exe на Windows
Hello, world!
```

Гоп! Якщо все пройшло добре, ви знову побачите в терміналі `Hello, world!`. 
Запуск `cargo build` уперше також призводить до створення Cargo нового файлу в
головній теці проєкту, що зветься *Cargo.lock*. Цей файл використовується для
відстеження конкретних версій залежностей вашого проєкту. Цей проєкт не має 
залежностей, тому він не надто великий. Вам не треба нічого самостійно робити 
із цим файлом, його вмістом займається Cargo.

Ми щойно побудували проєкт командою `cargo build` і запустили командою
`./target/debug/hello_cargo`, але також можна скористатися командою `cargo run`,
щоб скомпілювати та запустити все за одну дію:

```text
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

Зверніть увагу, що цього разу ми не побачили повідомлення про те, що Cargo 
компілює `hello_cargo`. Cargo зрозумів, що файли не змінилися, тому просто 
запустив двійковий файл. Якби ви змінили сирцевий код, Cargo б перебудував 
проєкт перед виконанням, і ви б побачили щось схоже на це:

```text
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

Нарешті, є `cargo check`. Ця команда швидко перевіряє ваш код, щоб переконатися, що він компілюється, але не створює виконанного файлу:

```text
$ cargo check
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```

Чому виконанний файл може бути непотрібним? `cargo check` зазвичай працює 
значно швидше за `cargo build`, бо повністю пропускає створення виконанного 
файлу. Якщо ви перевіряєте вашу роботу під час написанння коду, використання `
cargo check` прискорить роботу. Ось чому багато растацеанців запускають `cargo 
check` час від часу поки пишуть програми, щоб переконатися, що вони 
компілюються, а потім запускають `cargo build`, коли готові перевірити її 
роботу.

Підіб'ємо підсумок. За допомогою Cargo:

- Ми можемо побудувати проєкт за допомогою `cargo build` чи `cargo check`;
- Ми можемо побудувати і запустити проєкт в одну дію за допомогою `cargo run`;
- Результат побудови Cargo розміщує не в одній теці із кодом, а в теці 
*target/debug*.

Остання перевага використання Cargo полягає в тому, що його команди однакові
незалежно від операційної системи, в якій ви працюєте, тому з цього моментути
більше не надаватимемо окремих команд для Linux, macOS чи Windows.

### Побудова для випуску

Коли ваш проєкт нарешті готовий для релізу, ви можете запустити `cargo build
--release` для компіляції проєкту з оптимізаціями. Це створить викоанний файл 
у теці  *target/release* замість *target/debug*. Ці оптимізації дозволяють 
коду Rust працювати швидше, але сповільнюють процес компіляції. Ось чому є два 
різні профілі: один для розробки, щоб можна було перебудовувати часто і 
швидко, та інший для побудови фінальної програми, яку можна дати користувачеві,
яку не треба часто перебудовувати і яка буде виконуватися якомога швидше. Якщо 
ви перевіряєте швидкість виконання вашого коду, запускайте `cargo build --release` і перевіряйте виконанний файл у *target/release*.

### Cargo як стандарт

У простих проєктах Cargo надає не набагато більше можливостей за `rustc`, але в
подальшому вона виявить свою цінність. У складних проєктах, що складаються з 
багатьох crate-ів, набагато простіше координувати побудову за допомогою Cargo.

Хоча наш проєкт `hello_cargo` і нескладний, тепер він використовує багато 
інструментів, якими ви будете користатися решту вашої кар'єри з Rust. 
Фактично, щоб працювати із будь-яким існуючим проєктом ви можете скористатися 
цими командами, щоб завантажити код за допомогою Git, перейти до теки проєкту 
і побудувати його:

```text
$ git clone someurl.com/someproject
$ cd someproject
$ cargo build
```

Якщо ми хочете детальніше розібратися з Cargo, зазирніть до [його документації][its documentation].

[its documentation]: https://doc.rust-lang.org/cargo/

<!--Below -- I`m not sure this is the place for this conversation, it seems too
deep into the weeds for the "getting started" chapter. I know we discussed
Nightly Rust as an appendix previously, but honestly I think this is more
suited somewhere online, perhaps in the extended docs. I like the idea of
finishing the chapter here, on this practical note, and I think at this point
readers will want to get stuck in anyway and may skip this and never come back
because it's buried at the end of a chapter that's not really related to it. If
it's online somewhere separate they can come to it when they're ready. What do
you think?-->
<!-- Ok, I can see that. /Carol -->

## Підсумок

Це був непоганий початок вашої подорожі Rust! У цьому розділі, ви:

* Встановили останню стабільну версію Rust;
* Написали програму “Hello, world!” за допомогою `rustc` безпосередньо і через
стандартний інструмент `cargo`.

Настав час побудувати більш змістовну програму, щоб призвичаїтися до читання 
та написання коду Rust. У наступному розділі ми створимо програму для 
відгадування числа. Якщо ви натомість бажаєте почати з вивчення, як 
загальні концепції програмування працюють в Rust, переходьте до Розділу 3.
