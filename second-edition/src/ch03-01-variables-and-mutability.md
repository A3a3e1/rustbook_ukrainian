## Змінні і сталість

Як вже згадувалося у Розділі 2, усталено змінні є *сталими* (*immutable*). Це 
- один з численних штурханців, якими Rust заохочує вас писати код, що 
користується перевагами у безпеці та швидкості, які надає Rust. Тим не менш, 
ви все ж маєте можливість зробити змінні несталими. Дослідимо, як і чому Rust 
заохочує вас надавати перевагу сталості, та чому ви можете захотіти 
відмовитися від цього.

Якщо змінна є сталою, це означає, що відколи значення стає прив'язаним до 
імені, ви не можете змінити це значення. Для прикладу згенеруємо новий проект 
з назвою *variables* у вашій теці *projects* за допомгою `cargo new --bin variables`.

Потім, у новоствореній теці *variables*, відкрийте *src/main.rs* і замініть 
його код таким:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
fn main() {
    let x = 5;
    println!("Значення x: {}", x);
    x = 6;
    println!("Значення x: {}", x);
}
```

Збережіть і запустіть програму за допомогою `cargo run`. Ви дістанете 
повідомлення про помилку, як показано тут:

```text
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!("Значення x: {}", x);
4 |     x = 6;
  |     ^^^^^ re-assignment of immutable variable
```

Цей приклад показує, як компілятор допомагає вам знаходити помилки у ваших 
програмах. Хоча повідомлення компілятора про помилки й можуть бути неприємними,
вони лише означають, що ваша програма ще не робить те, що ви хотіли, у 
безпечний спосіб; вони *не* означають, що ви поганий програміст! Досвідчені 
растацеанці також отримують повідомлення про помилки від компілятора.

Повідомлення вказує, що причиною помилки є те, що ми "не можемо присвоювати 
двічі сталій змінній `x`" (`cannot assign twice to immutable variable x`), бо 
ми намагалися присвоїти друге значення сталій змінній `x`.

Важливо, що ми отримали помилку часу компіляції, коли намагалися змінити 
значення, яке раніше визначили як стале, тому що ця ситуація може призвести до
вад у програмі. Якщо одна частина нашого коду працює з припущенням, що значення
не буде змінене, а інша частина нашого коду змінює це значення, можливо, що 
перша частина коду буде робити не те, для чого вона була зроблена. Цю причину 
вад важко відслідкувати після виявлення, особливо коли другий шмат коду змінює
значення лише *іноді*.

У Rust компілятор гарантує, що, якщо ми заявили, що змінна не зміниться, вона і
дійсно не зміниться. Це означає, що коли ви читаєте і пишете код, вам не треба
відстежувати, як і де значення може змінитися, що може полегшити обмірковування
коду.

Але несталість може бути вкрай корисною. Змінні є сталими тільки типово; ми 
можемо зробити їх несталими, додавши `mut` перед ім'ям змінної. На додачу до
дозволу змінювати це значення, це попереджає майбутніх читачим коду про ваші 
наміри, вказуючи, що інші частини коду будуть змінювати значення цієї змінної.

Наприклад, змінимо *src/main.rs* на такий код:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    let mut x = 5;
    println!("Значення x: {}", x);
    x = 6;
    println!("Значення x: {}", x);
}
```

Запустивши програму ми отримаємо:

```text
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
```

Застосувавши `mut`, ми дозволили змінити значення, прив'язане до `x`, з `5` на
`6`. У деяких випадках, вам захочеться робити змінні несталими, бо так зручніше
писати код, ніж у реалізації з виключно сталими змінними.

Варто розглядати й інші аспекти, крім запобігання вадам. Наприклад, якщо ви
використовуєте великі структури даних, змінювати екземпляр на місці може бути 
швидше, ніж копіювати і повертати наново виділений екземпляр. Для менших
структур даних може бути зручнішим розмірковувати про код, написаний у більш 
функціональному стилі, з постійним створенням нових екземплярів, тому може бути
варто знизити продуктивність заради збільшення ясності.

### Відмінності між змінними та константами

Неможливість змінити значення змінної може нагадати вам про іншу концепцію 
программування, що є в більшості мов: *константи*. Константи - це так само 
значення, прив'язані до імені, які не можна змінювати, але є кілька 
відмінностей між константами і змінними. По-перше, використання `mut` з 
константами неможливе: константи не тільки типово сталі, вони завжди сталі. 
Константи проголошуються ключовим словом `const` замість `let`, і тип значення 
*має* явно позначатися. Ми розкажемо про типи і позначки типів у наступному 
розділі, "Типи даних", тому не хвилюйтеся зараз про деталі. Константи можуть 
проголошуватися у будь-яких межах дії, у тому числі глобальних, що робить їх 
корисними для зберігання значення, яке використовується у багатьох частинах 
вашого коду.
Остання відмнінність полягає в тому, що константи можуть набувати тільки 
значення константних виразів, а не результатів виклику функції чи інших 
значень, які можуть бути використані лише під час виконання програми.

Ось приклад проголошення константи, де константа зветься `MAX_POINTS`, а її 
значення є 100,000. Угода про назви констант в Rust вимагає використання 
верхнього регістру із підкресленнями між словам:

```
const MAX_POINTS: u32 = 100_000;
```

Константи діють протягом усього часу життя програми, у тих межах дії, де вони 
були проголошені. Це робить константи корисними для зберігання значень у 
вашому додатку, про які необхідно знати багатьом частинам програми, наприклад 
максимальна кількість балів, яку може отримати гравець чи кількість секунд у 
році.

Корисно давати назви жорстко задані значення, що використовуються по всій 
програмі, позначаючи їх константами, щоб передати сенс цього значення тим, хто
супроводжуватиме код. Це також корисно тим, що ви в коді буде тільки одне 
місце, яке буде необхідно змінити, у разі потреби оновити жорстко задане 
значення.

### Затінення

Як ми бачили у Розділі 2, можна проголошувати нові змінні із таким самим 
іменем, як і в раніше проголошених змінних, і нова змінна *затінює* попередню 
змінну. Растацеанці кажуть, що перша змінна *затінена* другою, що означає, що 
при використанні змінної ми отримаємо значення другої змінної. Ми можемо 
затінити змінну за допомогою ключового слова `let` та імені цієї змінної:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!("Значення x: {}", x);
}
```

Ця програма спершу прив'язує `x` до значення `5`. Потім затінює `x` повторенням
`let x =`, взявши початкове значення і додавши до нього `1`, так що значення `x`
стає `6`. Третя інструкція `let` також затінює `x`, бере попереднє значення і
множить його на `1`, щоб надати `x` остатночного значення `12`. Якщо запустити
цю програму, вона виведе:

```text
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/variables`
The value of x is: 12
```

Це відрізняється від позначення змінної `mut`, адже якщо ми знову не 
використаємо ключове слово `let`, отримаємо помилку часу компіляції, якщо 
випадково спробуємо переприсвоїти значення цієї змінної. Ми можемо 
перетворювати значення, але змінна буде сталою після виконання цих перетворень.

Інша різниця між `mut` та затіненням полягає в тому, що оскільки коли пишемо 
знову ключове слово `let`, насправді ми створюємо нову змінну, тоже можемо 
змінити тип значення, але залишити ім'я. Наприклад, хай наша програма просить
користувача вказати, скільки пробілів має бути всередині якогось тексту, ввівши
символи пробілу, але насправді ми хочемо зберігати це значення як число:

```rust
let spaces = "   ";
let spaces = spaces.len();
```

Ця конструкція можлива, бо перша змінна `spaces` має стрічковий тип, а друга
змінна `spaces`, що є повністю новою змінною, якій трапилося мати таке саме 
ім'я, має числовий тип. Затінення, таким чином, позбавляє нас необхідності 
придумувати різні імена, на кшталт `spaces_str` та `spaces_num`; натомість, ми
можемо заново використати простіше ім'я `spaces`. Але якщо ми спробуємо 
скористатися `mut`, як показано:

```rust,ignore
let mut spaces = "   ";
spaces = spaces.len();
```

Ми отримаємо помилку часу компіляції, бо не можна змінювати тип змінної:

```text
error[E0308]: mismatched types
 --> src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected &str, found usize
  |
  = note: expected type `&str`
             found type `usize`
```ound type `usize`
```

Тепер, дослідивши, як працюють змінні, погляньмо, які типи данних вони можуть 
зберігати.